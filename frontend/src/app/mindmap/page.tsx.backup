'use client';

import { useState, useEffect, useRef, useCallback } from 'react';
import Link from 'next/link';
import MindMapNode from '../../components/MindMapNode';
import CurvedConnection from '../../components/CurvedConnection';
import ToolBar, { ToolType } from '../../components/ToolBar';
import DrawingCanvas from '../../components/DrawingCanvas';
import { StorageManager } from '../../utils/storage';
import { MindMapNode as MindMapNodeType, Connection } from '../../types';
import { 
  getFixedGridSize,
  type ScreenDimensions
} from '../../utils/scaling-utils';
import { calculateNodeSize, getDefaultNodeSize } from '../../utils/nodeSize';

const CANVAS_SIZE = 5000; // Large canvas size for infinite scrolling
const CANVAS_CENTER = CANVAS_SIZE / 2;

interface GridBackgroundProps {
  offsetX: number;
  offsetY: number;
  viewWidth: number;
  viewHeight: number;
}

function GridBackground({ offsetX, offsetY, viewWidth, viewHeight }: GridBackgroundProps) {
  const gridSize = getFixedGridSize('web');
  
  // Calculate visible grid lines with buffer
  const startX = Math.floor(offsetX / gridSize) * gridSize - gridSize;
  const startY = Math.floor(offsetY / gridSize) * gridSize - gridSize;
  const endX = startX + viewWidth + gridSize * 3;
  const endY = startY + viewHeight + gridSize * 3;
  
  const verticalLines = [];
  const horizontalLines = [];
  
  // Generate vertical lines
  for (let x = startX; x <= endX; x += gridSize) {
    verticalLines.push(
      <div
        key={`v-${x}`}
        className="absolute top-0 h-full w-px bg-gray-200"
        style={{ left: x - offsetX }}
      />
    );
  }
  
  // Generate horizontal lines
  for (let y = startY; y <= endY; y += gridSize) {
    horizontalLines.push(
      <div
        key={`h-${y}`}
        className="absolute left-0 w-full h-px bg-gray-200"
        style={{ top: y - offsetY }}
      />
    );
  }
  
  return (
    <div className="absolute inset-0 overflow-hidden">
      {verticalLines}
      {horizontalLines}
    </div>
  );
}

// Use the type from types file

export default function MindMapPage() {
  const [dimensions, setDimensions] = useState<ScreenDimensions>({ width: 0, height: 0 });
  const [offset, setOffset] = useState({ x: CANVAS_CENTER, y: CANVAS_CENTER });
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState({ x: 0, y: 0, offsetX: 0, offsetY: 0 });
  const [lastClickTime, setLastClickTime] = useState(0);
  const [lastClickPos, setLastClickPos] = useState({ x: 0, y: 0 });
  
  // Restored editing coordination state (without visual effects)
  const [currentEditingNodeId, setCurrentEditingNodeId] = useState<string | null>(null);
  
  // Global state for connection mode
  const [connectionSourceNodeId, setConnectionSourceNodeId] = useState<string | null>(null);
  const [isConnectionMode, setIsConnectionMode] = useState<boolean>(false);
  const connectionTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  
  // Connection selection state
  const [selectedConnectionId, setSelectedConnectionId] = useState<string | null>(null);
  
  // Node selection state
  const [selectedNodeId, setSelectedNodeId] = useState<string | null>(null);
  
  // Drag connection states
  const [isConnectionDragging, setIsConnectionDragging] = useState<boolean>(false);
  const [connectionDragPosition, setConnectionDragPosition] = useState<{ x: number; y: number } | null>(null);
  const [connectionDragStartNode, setConnectionDragStartNode] = useState<{ id: string; x: number; y: number } | null>(null);
  
  // Base node dimensions (will be calculated dynamically per node)
  const { width: baseNodeWidth, height: baseNodeHeight } = getDefaultNodeSize();
  const fontSize = 15;
  const [nodes, setNodes] = useState<MindMapNodeType[]>([
    { 
      id: '1', 
      title: 'Idea Centrale', 
      x: 0, 
      y: 0,
      borderColor: '#4f46e5'
    },
    {
      id: '2',
      title: 'Strategia Marketing',
      x: -250,
      y: -150,
      borderColor: '#f59e0b'
    },
    {
      id: '3',
      title: 'Sviluppo Prodotto',
      x: 250,
      y: -150,
      borderColor: '#10b981'
    },
    {
      id: '4',
      title: 'Analisi Mercato',
      x: -250,
      y: 150,
      borderColor: '#ef4444'
    },
    {
      id: '5',
      title: 'Team Building',
      x: 250,
      y: 150,
      borderColor: '#8b5cf6'
    },
    {
      id: '6',
      title: 'Finanze',
      x: 0,
      y: -250,
      borderColor: '#22c55e'
    },
    {
      id: '7',
      title: 'Partnership',
      x: 0,
      y: 250,
      borderColor: '#f97316'
    }
  ]);
  
  const [connections, setConnections] = useState<Connection[]>([
    {
      id: 'conn-1-2',
      sourceId: '1',
      targetId: '2',
      type: 'curved',
      adaptiveCurvature: true,
      curvatureDirection: 'auto',
      color: '#6b7280',
      width: 2,
      showArrow: true,
      arrowPosition: 'end'
    },
    {
      id: 'conn-1-3',
      sourceId: '1',
      targetId: '3',
      type: 'curved',
      adaptiveCurvature: true,
      curvatureDirection: 'auto',
      color: '#6b7280',
      width: 2,
      showArrow: true,
      arrowPosition: 'end'
    },
    {
      id: 'conn-1-4',
      sourceId: '1',
      targetId: '4',
      type: 'curved',
      adaptiveCurvature: true,
      curvatureDirection: 'auto',
      color: '#6b7280',
      width: 2,
      showArrow: true,
      arrowPosition: 'end'
    },
    {
      id: 'conn-1-5',
      sourceId: '1',
      targetId: '5',
      type: 'curved',
      adaptiveCurvature: true,
      curvatureDirection: 'auto',
      color: '#6b7280',
      width: 2,
      showArrow: true,
      arrowPosition: 'end'
    },
    {
      id: 'conn-1-6',
      sourceId: '1',
      targetId: '6',
      type: 'curved',
      adaptiveCurvature: true,
      curvatureDirection: 'auto',
      color: '#6b7280',
      width: 2,
      showArrow: true,
      arrowPosition: 'end'
    },
    {
      id: 'conn-1-7',
      sourceId: '1',
      targetId: '7',
      type: 'curved',
      adaptiveCurvature: true,
      curvatureDirection: 'auto',
      color: '#6b7280',
      width: 2,
      showArrow: true,
      arrowPosition: 'end'
    }
  ]);
  
  const [currentMindMapId, setCurrentMindMapId] = useState<string>('temp');
  const [debugCoords, setDebugCoords] = useState({
    nodeX: 0,
    nodeY: 0,
    liveNodeX: 0,
    liveNodeY: 0,
    offsetX: CANVAS_CENTER,
    offsetY: CANVAS_CENTER,
    screenX: 0,
    screenY: 0,
    isDragging: false,
    isNodeDragging: false
  });
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const updateDimensions = () => {
      const newDimensions = {
        width: window.innerWidth,
        height: window.innerHeight,
      };
      setDimensions(newDimensions);
    };

    updateDimensions();
    window.addEventListener('resize', updateDimensions);
    return () => window.removeEventListener('resize', updateDimensions);
  }, []);

  // Update debug coordinates when offset or nodes change
  useEffect(() => {
    const firstNode = nodes[0];
    if (firstNode) {
      const nodeDimensions = calculateNodeSize(firstNode.title);
      const screenX = dimensions.width / 2 + firstNode.x - nodeDimensions.width / 2 - offset.x + CANVAS_CENTER;
      const screenY = dimensions.height / 2 + firstNode.y - nodeDimensions.height / 2 - offset.y + CANVAS_CENTER;
      
      setDebugCoords(prev => ({
        ...prev,
        nodeX: Math.round(firstNode.x),
        nodeY: Math.round(firstNode.y),
        offsetX: Math.round(offset.x),
        offsetY: Math.round(offset.y),
        screenX: Math.round(screenX),
        screenY: Math.round(screenY),
        isDragging: isDragging
      }));
    }
  }, [offset, nodes, dimensions, isDragging]);

  const createNewNode = useCallback((x: number, y: number) => {
    const relativeX = x - dimensions.width / 2 + offset.x - CANVAS_CENTER;
    const relativeY = y - dimensions.height / 2 + offset.y - CANVAS_CENTER;
    
    const newNode: MindMapNodeType = {
      id: Date.now().toString(),
      title: 'Nuovo Nodo',
      x: relativeX,
      y: relativeY
    };
    
    setNodes(prevNodes => [...prevNodes, newNode]);
  }, [dimensions, offset]);


  const handleNodePositionChange = useCallback((nodeId: string, newX: number, newY: number) => {
    setNodes(prevNodes => 
      prevNodes.map(node => 
        node.id === nodeId ? { ...node, x: newX, y: newY } : node
      )
    );
  }, []);

  const handleNodeDragStateChange = useCallback((isDragging: boolean) => {
    setDebugCoords(prev => ({
      ...prev,
      isNodeDragging: isDragging
    }));
  }, []);

  const handleLivePositionUpdate = useCallback((liveX: number, liveY: number) => {
    setDebugCoords(prev => ({
      ...prev,
      liveNodeX: Math.round(liveX),
      liveNodeY: Math.round(liveY)
    }));
  }, []);

  const handleTitleChange = useCallback((nodeId: string, newTitle: string) => {
    setNodes(prevNodes => 
      prevNodes.map(node => 
        node.id === nodeId ? { ...node, title: newTitle } : node
      )
    );
  }, []);

  const handleEditStateChange = useCallback((nodeId: string, isEditing: boolean) => {
    setCurrentEditingNodeId(isEditing ? nodeId : null);
  }, []);

  const createConnection = useCallback((sourceId: string, targetId: string) => {
    // Validation checks
    if (sourceId === targetId) {
      return; // No self-connections
    }
    
    // Check if connection already exists (in either direction)
    const connectionExists = connections.some(conn => 
      (conn.sourceId === sourceId && conn.targetId === targetId) ||
      (conn.sourceId === targetId && conn.targetId === sourceId)
    );
    
    if (connectionExists) {
      return; // No duplicate connections
    }
    
    // Create new connection
    const newConnection: Connection = {
      id: `conn-${sourceId}-${targetId}-${Date.now()}`,
      sourceId: sourceId,
      targetId: targetId,
      type: 'curved',
      adaptiveCurvature: true,
      curvatureDirection: 'auto',
      color: '#6b7280',
      width: 2,
      showArrow: true,
      arrowPosition: 'end'
    };
    
    setConnections(prevConnections => [...prevConnections, newConnection]);
  }, [connections]);

  const handleConnectionClick = useCallback((nodeId: string, isCtrlClick: boolean) => {
    // First node selection: requires Ctrl+Click
    if (!connectionSourceNodeId) {
      if (!isCtrlClick) return; // Only Ctrl+Click for first node
      
      // Clear any existing timeout
      if (connectionTimeoutRef.current) {
        clearTimeout(connectionTimeoutRef.current);
      }
      
      setConnectionSourceNodeId(nodeId);
      setIsConnectionMode(true);
      
      // Set 3-second timeout to clear connection mode
      connectionTimeoutRef.current = setTimeout(() => {
        setConnectionSourceNodeId(null);
        setIsConnectionMode(false);
        setSelectedNodeId(null); // Clear node selection on timeout
        connectionTimeoutRef.current = null;
      }, 3000);
      
      return;
    }
    
    // Already in connection mode - second node selection
    if (connectionSourceNodeId === nodeId) {
      // Same node clicked again: cancel connection mode
      setConnectionSourceNodeId(null);
      setIsConnectionMode(false);
      setSelectedNodeId(null); // Clear node selection when canceling connection mode
      if (connectionTimeoutRef.current) {
        clearTimeout(connectionTimeoutRef.current);
        connectionTimeoutRef.current = null;
      }
    } else {
      // Different node: create connection (no Ctrl needed for second node)
      createConnection(connectionSourceNodeId, nodeId);
      setConnectionSourceNodeId(null);
      setIsConnectionMode(false);
      setSelectedNodeId(null); // Clear node selection after connection creation
      if (connectionTimeoutRef.current) {
        clearTimeout(connectionTimeoutRef.current);
        connectionTimeoutRef.current = null;
      }
    }
  }, [connectionSourceNodeId, createConnection]);

  const handleConnectionDragStart = useCallback((nodeId: string, mouseX: number, mouseY: number) => {
    // Clear any existing connection mode/timeout
    if (connectionTimeoutRef.current) {
      clearTimeout(connectionTimeoutRef.current);
      connectionTimeoutRef.current = null;
    }
    
    // Find the node to get its position
    const node = nodes.find(n => n.id === nodeId);
    if (!node) return;
    
    // Calculate node's dynamic dimensions and screen position
    const nodeDimensions = calculateNodeSize(node.title);
    const nodeScreenX = dimensions.width / 2 + node.x - nodeDimensions.width / 2 - offset.x + CANVAS_CENTER;
    const nodeScreenY = dimensions.height / 2 + node.y - nodeDimensions.height / 2 - offset.y + CANVAS_CENTER;
    
    // Start drag connection mode
    setConnectionDragStartNode({ 
      id: nodeId, 
      x: nodeScreenX + nodeDimensions.width / 2, 
      y: nodeScreenY + nodeDimensions.height / 2 
    });
    setIsConnectionDragging(true);
    setConnectionDragPosition({ x: mouseX, y: mouseY });
    
    // Also set connection mode for visual feedback
    setConnectionSourceNodeId(nodeId);
    setIsConnectionMode(true);
  }, [nodes, dimensions, offset]);

  const handleConnectionDragEnd = useCallback((targetNodeId?: string) => {
    if (!connectionDragStartNode) return;
    
    if (targetNodeId && targetNodeId !== connectionDragStartNode.id) {
      // Create connection
      createConnection(connectionDragStartNode.id, targetNodeId);
    }
    
    // Clear all drag connection states
    setIsConnectionDragging(false);
    setConnectionDragPosition(null);
    setConnectionDragStartNode(null);
    setConnectionSourceNodeId(null);
    setIsConnectionMode(false);
    setSelectedNodeId(null); // Clear node selection after drag connection
  }, [connectionDragStartNode, createConnection]);

  const handleNodeDelete = useCallback((nodeId: string) => {
    // Remove the node
    setNodes(prevNodes => prevNodes.filter(node => node.id !== nodeId));
    
    // Remove all connections associated with this node
    setConnections(prevConnections => 
      prevConnections.filter(connection => 
        connection.sourceId !== nodeId && connection.targetId !== nodeId
      )
    );
    
    // Clear editing state if the deleted node was being edited
    if (currentEditingNodeId === nodeId) {
      setCurrentEditingNodeId(null);
    }
    
    // Clear connection mode if deleted node was source
    if (connectionSourceNodeId === nodeId) {
      setConnectionSourceNodeId(null);
      setIsConnectionMode(false);
      if (connectionTimeoutRef.current) {
        clearTimeout(connectionTimeoutRef.current);
        connectionTimeoutRef.current = null;
      }
    }
    
    // Clear node selection if deleted node was selected
    if (selectedNodeId === nodeId) {
      setSelectedNodeId(null);
    }
  }, [currentEditingNodeId, connectionSourceNodeId, selectedNodeId]);
  
  

  const handleConnectionDelete = useCallback((connectionId: string) => {
    setConnections(prevConnections => 
      prevConnections.filter(connection => connection.id !== connectionId)
    );
    // Clear selection if deleted connection was selected
    if (selectedConnectionId === connectionId) {
      setSelectedConnectionId(null);
    }
  }, [selectedConnectionId]);

  const handleConnectionSelect = useCallback((connectionId: string) => {
    setSelectedConnectionId(selectedConnectionId === connectionId ? null : connectionId);
  }, [selectedConnectionId]);
  
  const handleNodeSelect = useCallback((nodeId: string) => {
    setSelectedNodeId(selectedNodeId === nodeId ? null : nodeId);
  }, [selectedNodeId]);
  
  
  const handleToolChange = useCallback((tool: ToolType) => {
    setActiveTool(tool);
    
    // Clear any active states when switching tools
    if (currentEditingNodeId) {
      setCurrentEditingNodeId(null);
    }
    if (isConnectionMode) {
      setConnectionSourceNodeId(null);
      setIsConnectionMode(false);
      if (connectionTimeoutRef.current) {
        clearTimeout(connectionTimeoutRef.current);
        connectionTimeoutRef.current = null;
      }
    }
    if (selectedConnectionId) {
      setSelectedConnectionId(null);
    }
    if (selectedNodeId) {
      setSelectedNodeId(null);
    }
  }, [currentEditingNodeId, isConnectionMode, selectedConnectionId, selectedNodeId]);



  const handleMouseMove = useCallback((e: React.MouseEvent) => {
    // Handle connection dragging
    if (isConnectionDragging) {
      setConnectionDragPosition({ x: e.clientX, y: e.clientY });
      return;
    }
    
    // Handle normal background dragging
    if (!isDragging) return;
    
    const deltaX = e.clientX - dragStart.x;
    const deltaY = e.clientY - dragStart.y;
    
    setOffset({
      x: dragStart.offsetX - deltaX,
      y: dragStart.offsetY - deltaY
    });
  }, [isDragging, dragStart, isConnectionDragging]);

  const handleMouseUp = useCallback(() => {
    // Handle connection drag end
    if (isConnectionDragging) {
      handleConnectionDragEnd();
      return;
    }
    
    // Handle normal drag end
    setIsDragging(false);
  }, [isConnectionDragging, handleConnectionDragEnd]);


  // Export mind map - directly from current state
  const exportMindMap = useCallback(() => {
    try {
      const mindMapData = {
        id: currentMindMapId,
        title: 'Test Mind Map',
        nodes: nodes,
        connections: connections,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      };

      const exportData = {
        version: '1.0',
        mindMap: mindMapData,
        exportedAt: Date.now(),
      };

      const dataStr = JSON.stringify(exportData, null, 2);
      const dataBlob = new Blob([dataStr], { type: 'application/json' });
      
      const url = URL.createObjectURL(dataBlob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `mindmap-${mindMapData.title.replace(/[^a-z0-9]/gi, '_')}.json`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
      alert('Mind Map esportata con successo!');
    } catch (error) {
      alert('Errore durante l\'esportazione: ' + (error as Error).message);
    }
  }, [currentMindMapId, nodes, connections]);

  // Import mind map
  const importMindMap = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    StorageManager.uploadMindMapJSON(file)
      .then((importedMindMap) => {
        setCurrentMindMapId(importedMindMap.id);
        setNodes(importedMindMap.nodes);
        setConnections(importedMindMap.connections || []);
        alert('Mind Map importata con successo!');
      })
      .catch((error) => {
        alert('Errore durante l\'importazione: ' + error.message);
      });
      
    // Reset file input
    event.target.value = '';
  }, []);

  // Toolbar state (moved up to avoid reference errors)
  const [activeTool, setActiveTool] = useState<ToolType>('select');
  
  const handleEraserClick = useCallback((target: 'node' | 'connection', id: string) => {
    if (activeTool !== 'eraser') return;
    
    if (target === 'node') {
      handleNodeDelete(id);
    } else if (target === 'connection') {
      handleConnectionDelete(id);
    }
  }, [activeTool, handleNodeDelete, handleConnectionDelete]);
  
  const handleBackgroundMouseDown = useCallback((e: React.MouseEvent) => {
    // Don't interfere with drawing canvas when pencil is active
    if (activeTool === 'pencil') {
      return;
    }
    
    // Only start dragging background if not clicking on a node
    if ((e.target as HTMLElement).closest('[data-node-id]')) {
      return;
    }
    
    const currentTime = Date.now();
    const currentPos = { x: e.clientX, y: e.clientY };
    
    // Check for double click (within 500ms and 10px distance)
    const timeDiff = currentTime - lastClickTime;
    const distance = Math.sqrt(
      Math.pow(currentPos.x - lastClickPos.x, 2) + 
      Math.pow(currentPos.y - lastClickPos.y, 2)
    );
    
    if (timeDiff < 500 && distance < 10) {
      // Double click detected - create new node and clear all selections
      createNewNode(e.clientX, e.clientY);
      setLastClickTime(0); // Reset to prevent triple click
      
      // Clear all selections on double click too
      if (currentEditingNodeId) {
        setCurrentEditingNodeId(null);
      }
      if (isConnectionMode) {
        setConnectionSourceNodeId(null);
        setIsConnectionMode(false);
        if (connectionTimeoutRef.current) {
          clearTimeout(connectionTimeoutRef.current);
          connectionTimeoutRef.current = null;
        }
      }
      if (selectedConnectionId) {
        setSelectedConnectionId(null);
      }
      if (selectedNodeId) {
        setSelectedNodeId(null);
      }
      return;
    }
    
    // Single click - clear selections and start dragging
    // Exit editing mode when clicking on background
    if (currentEditingNodeId) {
      setCurrentEditingNodeId(null);
    }
    
    // Cancel connection mode when clicking on background
    if (isConnectionMode) {
      setConnectionSourceNodeId(null);
      setIsConnectionMode(false);
      if (connectionTimeoutRef.current) {
        clearTimeout(connectionTimeoutRef.current);
        connectionTimeoutRef.current = null;
      }
    }
    
    // Clear connection selection when clicking on background
    if (selectedConnectionId) {
      setSelectedConnectionId(null);
    }
    
    // Clear node selection when clicking on background
    if (selectedNodeId) {
      setSelectedNodeId(null);
    }
    
    // Start dragging
    e.preventDefault();
    setIsDragging(true);
    setDragStart({
      x: e.clientX,
      y: e.clientY,
      offsetX: offset.x,
      offsetY: offset.y
    });
    
    // Store click info for potential double click
    setLastClickTime(currentTime);
    setLastClickPos(currentPos);
  }, [activeTool, offset, lastClickTime, lastClickPos, createNewNode, currentEditingNodeId, isConnectionMode, selectedConnectionId, selectedNodeId]);
  
  // Terminal container state
  const [showTerminal, setShowTerminal] = useState(false);
  const [terminalInput, setTerminalInput] = useState('');
  const [terminalHistory, setTerminalHistory] = useState<string[]>(['Welcome to Mind Map Terminal']);

  const handleTerminalSubmit = useCallback(() => {
    if (!terminalInput.trim()) return;
    
    const input = terminalInput.trim();
    const output = `user@mindmap:~$ ${input}`;
    
    // Simple command processing
    let response = '';
    if (input === 'help') {
      response = 'Available commands: help, clear, nodes, export, import';
    } else if (input === 'clear') {
      setTerminalHistory([]);
      setTerminalInput('');
      return;
    } else if (input === 'nodes') {
      response = `Found ${nodes.length} nodes in current mind map`;
    } else if (input === 'export') {
      exportMindMap();
      response = 'Exporting mind map...';
    } else {
      response = `bash: ${input}: command not found`;
    }
    
    setTerminalHistory(prev => [...prev, output, response]);
    setTerminalInput('');
  }, [terminalInput, nodes.length, exportMindMap]);

  const handleTerminalKeyPress = useCallback((e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      handleTerminalSubmit();
    } else if (e.key === 'Escape') {
      setShowTerminal(false);
    }
  }, [handleTerminalSubmit]);

  useEffect(() => {
    if (isDragging) {
      const handleGlobalMouseMove = (e: MouseEvent) => {
        const deltaX = e.clientX - dragStart.x;
        const deltaY = e.clientY - dragStart.y;
        
        setOffset({
          x: dragStart.offsetX - deltaX,
          y: dragStart.offsetY - deltaY
        });
      };

      const handleGlobalMouseUp = () => {
        setIsDragging(false);
      };

      document.addEventListener('mousemove', handleGlobalMouseMove);
      document.addEventListener('mouseup', handleGlobalMouseUp);
      
      return () => {
        document.removeEventListener('mousemove', handleGlobalMouseMove);
        document.removeEventListener('mouseup', handleGlobalMouseUp);
      };
    }
  }, [isDragging, dragStart]);

  useEffect(() => {
    if (isConnectionDragging) {
      const handleGlobalMouseMove = (e: MouseEvent) => {
        setConnectionDragPosition({ x: e.clientX, y: e.clientY });
      };

      const handleGlobalMouseUp = () => {
        handleConnectionDragEnd();
      };

      document.addEventListener('mousemove', handleGlobalMouseMove);
      document.addEventListener('mouseup', handleGlobalMouseUp);
      
      return () => {
        document.removeEventListener('mousemove', handleGlobalMouseMove);
        document.removeEventListener('mouseup', handleGlobalMouseUp);
      };
    }
  }, [isConnectionDragging, handleConnectionDragEnd]);

  // Keyboard handler for Delete key
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Only handle Delete/Backspace if not editing a node
      if (currentEditingNodeId) return;
      
      if (e.key === 'Delete' || e.key === 'Backspace') {
        if (selectedConnectionId) {
          e.preventDefault();
          handleConnectionDelete(selectedConnectionId);
        }
      }
      
      // Escape key to deselect
      if (e.key === 'Escape') {
        if (selectedConnectionId) {
          setSelectedConnectionId(null);
        }
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    return () => document.removeEventListener('keydown', handleKeyDown);
  }, [selectedConnectionId, currentEditingNodeId, handleConnectionDelete]);

  return (
    <div 
      ref={containerRef}
      className="fixed inset-0 bg-white overflow-hidden"
      style={{ userSelect: 'none' }}
    >
      {/* Grid Background - only this layer should be draggable */}
      <div
        className="absolute inset-0 cursor-grab active:cursor-grabbing"
        onMouseDown={handleBackgroundMouseDown}
        onMouseMove={handleMouseMove}
        onMouseUp={handleMouseUp}
      >
        <GridBackground 
          offsetX={offset.x - dimensions.width / 2}
          offsetY={offset.y - dimensions.height / 2}
          viewWidth={dimensions.width}
          viewHeight={dimensions.height}
        />
      </div>

      {/* Connections Layer - positioned below nodes */}
      <div className="mindmap-connections">
        {connections.map((connection) => {
          const sourceNode = nodes.find(n => n.id === connection.sourceId);
          const targetNode = nodes.find(n => n.id === connection.targetId);
          
          if (!sourceNode || !targetNode) return null;
          
          return (
            <CurvedConnection
              key={connection.id}
              connection={connection}
              sourceNode={sourceNode}
              targetNode={targetNode}
              getNodeDimensions={calculateNodeSize}
              dimensions={dimensions}
              offset={offset}
              canvasCenter={CANVAS_CENTER}
              isSelected={selectedConnectionId === connection.id}
              onSelect={activeTool === 'eraser' ? () => handleEraserClick('connection', connection.id) : handleConnectionSelect}
              style={activeTool === 'eraser' ? { cursor: 'url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTIwIDIwSDdsLTctNyA5LjUtOS41YTMuNTQgMy41NCAwIDAgMSA1IDBsNCA0YTMuNTQgMy41NCAwIDAgMSAwIDVMMTMgMTguNSIgc3Ryb2tlPSIjZWY0NDQ0IiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9IiNmZWY5ZjkiLz4KPHN2Zz4K") 12 12, auto' } : undefined}
            />
          );
        })}
        
        {/* Connection Drag Preview */}
        {isConnectionDragging && connectionDragStartNode && connectionDragPosition && (
          <svg
            className="absolute inset-0 pointer-events-none"
            style={{ zIndex: 5 }}
          >
            <line
              x1={connectionDragStartNode.x}
              y1={connectionDragStartNode.y}
              x2={connectionDragPosition.x}
              y2={connectionDragPosition.y}
              stroke="#f59e0b"
              strokeWidth="2"
              strokeDasharray="5,5"
              opacity="0.7"
            />
            <circle
              cx={connectionDragPosition.x}
              cy={connectionDragPosition.y}
              r="3"
              fill="#f59e0b"
              opacity="0.7"
            />
          </svg>
        )}
      </div>

      {/* Mind Map Nodes - draggable */}
      {nodes.map((node) => {
        const nodeDimensions = calculateNodeSize(node.title);
        const screenX = dimensions.width / 2 + node.x - nodeDimensions.width / 2 - offset.x + CANVAS_CENTER;
        const screenY = dimensions.height / 2 + node.y - nodeDimensions.height / 2 - offset.y + CANVAS_CENTER;
        
        return (
          <div key={node.id} data-node-id={node.id} style={{ position: 'relative', zIndex: 10 }}>
            <MindMapNode 
              nodeId={node.id}
              title={node.title}
              color={node.color}
              borderColor={node.borderColor}
              width={nodeDimensions.width}
              height={nodeDimensions.height}
              x={screenX}
              y={screenY}
              onPositionChange={(newX, newY) => {
                const relativeX = newX - dimensions.width / 2 + nodeDimensions.width / 2 + offset.x - CANVAS_CENTER;
                const relativeY = newY - dimensions.height / 2 + nodeDimensions.height / 2 + offset.y - CANVAS_CENTER;
                handleNodePositionChange(node.id, relativeX, relativeY);
              }}
              onDragStateChange={handleNodeDragStateChange}
              onLivePositionUpdate={(liveX, liveY) => {
                const relativeX = liveX - dimensions.width / 2 + nodeDimensions.width / 2 + offset.x - CANVAS_CENTER;
                const relativeY = liveY - dimensions.height / 2 + nodeDimensions.height / 2 + offset.y - CANVAS_CENTER;
                handleLivePositionUpdate(relativeX, relativeY);
              }}
              onTitleChange={handleTitleChange}
              onEditStateChange={handleEditStateChange}
              isEditingFromParent={currentEditingNodeId === node.id}
              onDelete={handleNodeDelete}
              isSelected={selectedNodeId === node.id}
              onSelectionChange={handleNodeSelect}
              onConnectionClick={activeTool === 'eraser' ? () => handleEraserClick('node', node.id) : handleConnectionClick}
              isConnectionSource={connectionSourceNodeId === node.id}
              isInConnectionMode={isConnectionMode && activeTool === 'select'}
              onConnectionDragStart={activeTool === 'select' ? handleConnectionDragStart : undefined}
              onConnectionDragEnd={activeTool === 'select' ? handleConnectionDragEnd : undefined}
              style={activeTool === 'eraser' ? { cursor: 'url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTIwIDIwSDdsLTctNyA5LjUtOS41YTMuNTQgMy41NCAwIDAgMSA1IDBsNCA0YTMuNTQgMy41NCAwIDAgMSAwIDVMMTMgMTguNSIgc3Ryb2tlPSIjZWY0NDQ0IiBzdHJva2Utd2lkdGg9IjIiIGZpbGw9IiNmZWY5ZjkiLz4KPHN2Zz4K") 12 12, auto' } : undefined}
            />
          </div>
        );
      })}


      {/* Debug Coordinates Table */}
      <div className="absolute top-16 left-4 bg-black bg-opacity-80 text-white p-3 rounded-lg z-[1000] text-sm min-w-[150px]">
        <div className="font-bold mb-2">Debug Info</div>
        <div className="mb-1">Base: {baseNodeWidth}x{baseNodeHeight}</div>
        <div className="mb-1">Grid: {getFixedGridSize('web')}px (fixed)</div>
        <div className="mb-1">Font: {fontSize}px</div>
        <div className="mb-1">Node X: {debugCoords.nodeX}</div>
        <div className="mb-1">Node Y: {debugCoords.nodeY}</div>
        <div className="mb-1">Live X: {debugCoords.liveNodeX}</div>
        <div className="mb-1">Live Y: {debugCoords.liveNodeY}</div>
        <div className={`${debugCoords.isNodeDragging ? 'text-red-400' : 'text-green-400'}`}>
          Dragging: {debugCoords.isNodeDragging ? 'YES' : 'NO'}
        </div>
      </div>


      {/* Drawing Canvas Layer */}
      <DrawingCanvas
        isActive={activeTool === 'pencil'}
        dimensions={dimensions}
        offset={offset}
        canvasCenter={CANVAS_CENTER}
      />
      
      {/* Toolbar */}
      <ToolBar activeTool={activeTool} onToolChange={handleToolChange} />

      {/* Header with controls */}
      <div className="absolute top-4 left-4 z-20 pointer-events-auto flex gap-2">
        <Link 
          href="/chatbot"
          className="w-10 h-10 bg-white bg-opacity-90 rounded-full flex items-center justify-center shadow-lg hover:bg-opacity-100 transition-all duration-200 text-gray-700 text-xl font-medium hover:scale-105"
        >
          ←
        </Link>
        
        <button 
          onClick={() => setShowTerminal(!showTerminal)}
          className="px-3 py-2 bg-gray-800 bg-opacity-90 text-green-400 rounded-lg shadow-lg hover:bg-opacity-100 transition-all duration-200 text-sm font-medium hover:scale-105"
        >
          Terminal
        </button>
        
        <button 
          onClick={exportMindMap}
          className="px-3 py-2 bg-green-500 bg-opacity-90 text-white rounded-lg shadow-lg hover:bg-opacity-100 transition-all duration-200 text-sm font-medium hover:scale-105"
        >
          Export
        </button>
        
        <label className="px-3 py-2 bg-purple-500 bg-opacity-90 text-white rounded-lg shadow-lg hover:bg-opacity-100 transition-all duration-200 text-sm font-medium hover:scale-105 cursor-pointer">
          Import
          <input 
            type="file" 
            accept=".json" 
            onChange={importMindMap} 
            className="hidden" 
          />
        </label>
      </div>

      {/* Terminal Container */}
      {showTerminal && (
        <div className="fixed bottom-4 left-1/2 transform -translate-x-1/2 z-30 pointer-events-auto">
          <div className="w-[800px] h-[300px] bg-gray-900 rounded-xl p-4 shadow-2xl border border-gray-700">
            {/* Terminal Header */}
            <div className="flex items-center justify-between mb-3 pb-2 border-b border-gray-700">
              <div className="flex items-center gap-2">
                <div className="w-3 h-3 bg-red-500 rounded-full"></div>
                <div className="w-3 h-3 bg-yellow-500 rounded-full"></div>
                <div className="w-3 h-3 bg-green-500 rounded-full"></div>
                <span className="text-gray-400 text-sm font-mono ml-3">user@mindmap: ~</span>
              </div>
              <button
                onClick={() => setShowTerminal(false)}
                className="text-gray-400 hover:text-white text-sm"
              >
                ✕
              </button>
            </div>

            {/* Terminal Output */}
            <div className="h-[200px] overflow-y-auto mb-3 font-mono text-sm">
              {terminalHistory.map((line, index) => (
                <div 
                  key={index} 
                  className={line.startsWith('user@mindmap') ? 'text-green-400' : 'text-gray-300'}
                >
                  {line}
                </div>
              ))}
            </div>

            {/* Terminal Input */}
            <div className="flex items-center gap-2 font-mono text-sm">
              <span className="text-green-400">user@mindmap:~$</span>
              <input
                type="text"
                value={terminalInput}
                onChange={(e) => setTerminalInput(e.target.value)}
                onKeyPress={handleTerminalKeyPress}
                placeholder="Type 'help' for available commands"
                className="flex-1 bg-transparent text-gray-300 border-none outline-none placeholder-gray-500"
                autoFocus
              />
            </div>
          </div>
        </div>
      )}
    </div>
  );
}